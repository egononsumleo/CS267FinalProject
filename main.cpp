#include "RBS.h"
#include "stdc++.h"

int main(){
    int digits = 128;
	mpfr::mpreal::set_default_prec(mpfr::digits2bits(digits));

    /* Setting up */
    const int procs = 7;
    double eps = 0.1;
	const int PROBLEM_SIZE = 1000000; 
	const int M = 400;

	// vector<Selector*> selectors = {new MedianSelector(), new RandomSelector(), new QSelector()};
	MedianAnswerer answerer = MedianAnswerer();
	Solver solver = Solver();	
	// AdaptiveSolver solver = AdaptiveSolver();	

    /* Initialize the strategies that we will test */
    /* A strategy is a vector of length procs that decides on which quantiles we will query.
       For example, the Equal Splitting strategy will query at 1/p, 2/p, ... 1.
       The Median strategy always queries at 0.5.
    */

    vector< vector<F> > strategies;
    vector < string > strategy_name;

    /* START OF STRATEGIES */

    /* 1. Median strategy */
    vector<F> median;
    for(int i = 0;i < procs; ++i){
        median.push_back(0.5);
    }
    strategies.push_back(median);
    strategy_name.push_back("Parallel naive");

    /* 2. Equal Splitting strategy */
    vector<F> equal;
    for(int i = 0;i < procs; ++i){
        equal.push_back(float(i+1)/procs);
    }
    strategies.push_back(equal);
    strategy_name.push_back("Equal splitting");

    /* 3. Simple Lookahead strategy */
    // Given the way we modify the Bayesian posterior, the lookahead strategy should be very close to querying
    // 1/2, 1/2 - eps/procs, 1/2 + eps/procs, 1/2 - 2*eps/procs, 1/2 + 2*eps/procs, ...
    vector<F> simple_lookahead;
    for(int i = 0;i < procs; ++i) {
        int sign = 2*(i % 2) - 1; // sign is 1 on odd and -1 on even
        int magnitude = (i+1)/2; // magnitude is 0, 1, 1, 2, 2, ...
        simple_lookahead.push_back(0.5 + sign * magnitude * (double)eps/(double)procs);
    }
    strategies.push_back(simple_lookahead);
    strategy_name.push_back("Simple lookahead");

    /* 4. Actual Lookahead strategy */
    // Computes the actual quantiles by simulating all possibilities from look_ahead.py
    // 1 procs
    vector<F> lookahead = {0.5};
    // 3 procs
    // vector<F> lookahead = {0.4166666666666667, 0.5, 0.5833333333333334};
    // 7 procs
    // vector<F> lookahead = {0.34722222222222227, 0.4166666666666667, 0.48611111111111116, 0.5, 0.5138888888888888, 0.5833333333333334, 0.6527777777777778};
    // 15 procs
    // vector<F> lookahead = {0.2893518518518519, 0.34722222222222227, 0.40509259259259267, 0.4166666666666667, 0.4282407407407407, 0.4340277777777778, 0.48611111111111116, 0.5, 0.5138888888888888, 0.5659722222222224, 0.5717592592592593, 0.5833333333333334, 0.5949074074074073, 0.6527777777777778, 0.7106481481481481};
    // 31 procs
    // vector<F> lookahead = {0.2411265432098766, 0.2893518518518519, 0.33757716049382724, 0.34722222222222227, 0.3568672839506173, 0.3616898148148148, 0.3616898148148149, 0.40509259259259267, 0.4166666666666667, 0.4282407407407407, 0.4340277777777778, 0.4716435185185187, 0.4764660493827161, 0.48611111111111116, 0.4957561728395061, 0.5, 0.5042438271604939, 0.5138888888888888, 0.5235339506172839, 0.5283564814814815, 0.5659722222222224, 0.5717592592592593, 0.5833333333333334, 0.5949074074074073, 0.6383101851851851, 0.6383101851851853, 0.6431327160493827, 0.6527777777777778, 0.6624228395061728, 0.7106481481481481, 0.7588734567901234};
    // 63 procs
    // vector<F> lookahead = {0.2009387860082305, 0.2411265432098766, 0.2813143004115227, 0.2893518518518519, 0.2973894032921811, 0.3014081790123457, 0.30140817901234573, 0.30140817901234573, 0.33757716049382724, 0.34722222222222227, 0.3568672839506173, 0.3616898148148148, 0.3616898148148149, 0.39303626543209896, 0.3970550411522634, 0.40509259259259267, 0.4131301440329218, 0.4166666666666667, 0.42020318930041156, 0.421971450617284, 0.4282407407407407, 0.4340277777777778, 0.43627829218106995, 0.4402970679012346, 0.44608410493827155, 0.4521122685185185, 0.4521122685185186, 0.4716435185185187, 0.4764660493827161, 0.48611111111111116, 0.4957561728395061, 0.5, 0.5042438271604939, 0.5138888888888888, 0.5235339506172839, 0.5283564814814815, 0.5478877314814814, 0.5478877314814816, 0.5539158950617284, 0.5597029320987655, 0.56372170781893, 0.5659722222222224, 0.5717592592592593, 0.578028549382716, 0.5797968106995884, 0.5833333333333334, 0.5868698559670782, 0.5949074074074073, 0.6029449588477366, 0.6069637345679012, 0.6383101851851851, 0.6383101851851853, 0.6431327160493827, 0.6527777777777778, 0.6624228395061728, 0.6985918209876543, 0.6985918209876543, 0.6985918209876545, 0.7026105967078189, 0.7106481481481481, 0.7186856995884773, 0.7588734567901234, 0.7990612139917695};

    strategies.push_back(lookahead);
    strategy_name.push_back("Lookahead");

    /* 5. Entropy Optimal via Gradient Descent */
    // 1 procs
    vector<F> entropy_optimal = {0.5};
    // 3 procs
    // vector<F> entropy_optimal = {0.48073380387480535, 0.49999996428220667, 0.5192662973631037};
    // 7 procs
    // vector<F> entropy_optimal = {0.4635624410135427, 0.4813947555477728, 0.49837781584432167, 0.5, 0.5016218979707873, 0.5186050283718557, 0.5364375571500495};
    // 15 procs
    // vector<F> entropy_optimal = {0.44682301377817496, 0.4637143400093893, 0.47962723802743534, 0.4813562690251669, 0.48155226575351157, 0.49745287158137996, 0.49998999567787655, 0.49999999567787656, 0.5000099956778765, 0.5025473812353886, 0.5184477001077291, 0.5186435931686747, 0.5203731243436185, 0.536285815232788, 0.553177278919289};
    // 31 procs
    // vector<F> entropy_optimal = {0.43015326941020887, 0.44660087494765055, 0.4622698593474061, 0.46271200063645024, 0.463663865381379, 0.47853717859890554, 0.4804150215616535, 0.4804250215616535, 0.4804350215616535, 0.48187061542966286, 0.4964709372018966, 0.49648093720189657, 0.49812627715117735, 0.49998039928574345, 0.49999039928574346, 0.5000003992857435, 0.5000103992857434, 0.5000203992857435, 0.5018739941030633, 0.503519285465945, 0.503529285465945, 0.5181297779358827, 0.5195655750534574, 0.5195755750534574, 0.5195855750534574, 0.5214635901675466, 0.5363371429945477, 0.5372885234655407, 0.5377304045167289, 0.5533998758533965, 0.5698475056902559};
    // 63 procs
    // vector<F> entropy_optimal = {0.4152918523389327, 0.4304811495712107, 0.4451616712503585, 0.44564991585020686, 0.4471890988194534, 0.4609077606757841, 0.46207543774085075, 0.4620854377408507, 0.4620954377408507, 0.4645101967612611, 0.47781275940932677, 0.4778227594093268, 0.47922167484796724, 0.4793463371785009, 0.4793563371785009, 0.4793663371785009, 0.4793763371785009, 0.47938633717850093, 0.4814611055841553, 0.48271650526296284, 0.48272650526296285, 0.495910125637268, 0.49637651192061616, 0.49638651192061617, 0.4963965119206162, 0.4982920869796602, 0.4999501593631548, 0.49996015936315474, 0.49997015936315475, 0.49998015936315476, 0.4999901593631548, 0.5000001593631548, 0.5000101593631547, 0.5000201593631548, 0.5000301593631548, 0.5000401593631548, 0.5000501593631548, 0.5017078944544977, 0.5036034862509652, 0.5036134862509651, 0.5036234862509652, 0.5040898892586586, 0.5172740806553954, 0.5172840806553953, 0.5185387002994158, 0.5206135131959347, 0.5206235131959347, 0.5206335131959346, 0.5206435131959347, 0.5206535131959347, 0.520777210500872, 0.5221767779274706, 0.5221867779274706, 0.5354889104071354, 0.5379042154627235, 0.5379142154627234, 0.5379242154627235, 0.5390932735836644, 0.5528097103338222, 0.554349833516779, 0.5548371469522237, 0.5695193937852223, 0.584707434132887};

    strategies.push_back(entropy_optimal);
    strategy_name.push_back("Entropy optimal");

    /* 6. Entropy Optimal (slow) via Gradient Descent */
    bool option6_included = false;
    vector<F> entropy_optimal_slow;
    if (procs == 7) {
        entropy_optimal_slow = {0.3802347183227539, 0.42105579376220703, 0.4593982696533203, 0.49627113342285156, 0.532496452331543, 0.5688285827636719, 0.6061315536499023};
        option6_included = true;
    }
    if (procs == 12) {
        entropy_optimal_slow = {0.3222923278808594, 0.35715389251708984, 0.3894939422607422, 0.420135498046875, 0.4496583938598633, 0.47847747802734375, 0.5069131851196289, 0.5352382659912109, 0.5637197494506836, 0.5926542282104492, 0.6224336624145508, 0.6536483764648438};
        option6_included = true;
    }
    if (option6_included) {
        strategies.push_back(entropy_optimal_slow);
        strategy_name.push_back("Entropy optimal (slow)");
    }

    /* END OF STRATEGIES */

    std::uniform_int_distribution<> distrib(1, PROBLEM_SIZE-1); // constructs uniform distribution over the integers in [1, PROBLEM_SIZE)

    auto delta = mpfr::mpreal(.1); // we keep iterating until we have 1 - delta confidence => 1 - delta success rate

    for(int strat = 0; strat < strategies.size(); ++strat) { // for every strategy
        auto pivots = strategies[strat];

        F correct = 0;
        int total_flips = 0;
        for(int j = 0;j < M; ++j) {

            // Prepare the problem instance
            int answer = distrib(generator); // choose the answer that we want at random
            auto instance = StandardInstance(PROBLEM_SIZE, answer, eps); // initialize the problem instance where we have PROBLEM_SIZE number of coins with biases 1/2-eps, ..., 1/2-eps (<-answer), 1/2+eps, ..., 1/2+eps

            int iterations;
            int res = solver.solve(instance, pivots, answerer, eps, delta, iterations);

            if(res == answer) { // if we have successfully computed the answer
                ++ correct;
            }
            total_flips += iterations;
        }
        cout << "Strategy: " << strategy_name[strat] << " -- Accuracy: "  << correct/M << " -- Avg # of flips: " << (double)total_flips/(double)M << endl;
    }
}
